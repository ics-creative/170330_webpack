"use strict";(self.webpackChunktutorial_typescript_pixijs=self.webpackChunktutorial_typescript_pixijs||[]).push([[12],{9677:function(e,n,t){t.d(n,{I:function(){return $},v:function(){return T}});var r=t(836),o=t(1790),i=t(7694);function s(e,n,t){if(e)for(const r in e){const o=n[r.toLocaleLowerCase()];if(o){let n=e[r];"header"===r&&(n=n.replace(/@in\s+[^;]+;\s*/g,"").replace(/@out\s+[^;]+;\s*/g,"")),t&&o.push(`//----${t}----//`),o.push(n)}else(0,i.R)(`${r} placement hook does not exist in shader`)}}const u=/\{\{(.*?)\}\}/g;function a(e){const n={};return(e.match(u)?.map((e=>e.replace(/[{()}]/g,"")))??[]).forEach((e=>{n[e]=[]})),n}function l(e,n){let t;const r=/@in\s+([^;]+);/g;for(;null!==(t=r.exec(e));)n.push(t[1])}function c(e,n,t=!1){const r=[];l(n,r),e.forEach((e=>{e.header&&l(e.header,r)}));const o=r;t&&o.sort();const i=o.map(((e,n)=>`       @location(${n}) ${e},`)).join("\n");let s=n.replace(/@in\s+[^;]+;\s*/g,"");return s=s.replace("{{in}}",`\n${i}\n`),s}function d(e,n){let t;const r=/@out\s+([^;]+);/g;for(;null!==(t=r.exec(e));)n.push(t[1])}function f(e,n){let t=e;for(const e in n){const r=n[e];t=r.join("\n").length?t.replace(`{{${e}}}`,`//-----${e} START-----//\n${r.join("\n")}\n//----${e} FINISH----//`):t.replace(`{{${e}}}`,"")}return t}const m=Object.create(null),h=new Map;let p=0;function g({template:e,bits:n}){const t=x(e,n);return m[t]||(m[t]=v(e.vertex,e.fragment,n)),m[t]}function x(e,n){return n.map((e=>(h.has(e)||h.set(e,p++),h.get(e)))).sort(((e,n)=>e-n)).join("-")+e.vertex+e.fragment}function v(e,n,t){const r=a(e),o=a(n);return t.forEach((e=>{s(e.vertex,r,e.name),s(e.fragment,o,e.name)})),{vertex:f(e,r),fragment:f(n,o)}}const b="\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n",y="\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n",P="\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n",_="\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n",M={name:"global-uniforms-bit",vertex:{header:"\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        "}},w={name:"global-uniforms-bit",vertex:{header:"\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        "}};function T({bits:e,name:n}){const t=function({template:e,bits:n}){const t=x(e,n);if(m[t])return m[t];const{vertex:r,fragment:o}=function(e,n){const t=n.map((e=>e.vertex)).filter((e=>!!e)),r=n.map((e=>e.fragment)).filter((e=>!!e));let o=c(t,e.vertex,!0);return o=function(e,n){const t=[];d(n,t),e.forEach((e=>{e.header&&d(e.header,t)}));let r=0;const o=t.sort().map((e=>e.indexOf("builtin")>-1?e:`@location(${r++}) ${e}`)).join(",\n"),i=t.sort().map((e=>{return`       var ${n=e,n.replace(/@.*?\s+/g,"")};`;var n})).join("\n"),s=`return VSOutput(\n                ${t.sort().map((e=>` ${function(e){const n=/\b(\w+)\s*:/g.exec(e);return n?n[1]:""}(e)}`)).join(",\n")});`;let u=n.replace(/@out\s+[^;]+;\s*/g,"");return u=u.replace("{{struct}}",`\n${o}\n`),u=u.replace("{{start}}",`\n${i}\n`),u=u.replace("{{return}}",`\n${s}\n`),u}(t,o),{vertex:o,fragment:c(r,e.fragment,!0)}}(e,n);return m[t]=v(r,o,n),m[t]}({template:{fragment:y,vertex:b},bits:[M,...e]});return o.B.from({name:n,vertex:{source:t.vertex,entryPoint:"main"},fragment:{source:t.fragment,entryPoint:"main"}})}function $({bits:e,name:n}){return new r.M({name:n,...g({template:{vertex:P,fragment:_},bits:[w,...e]})})}},2305:function(e,n,t){t.d(n,{F:function(){return r},a:function(){return o}});const r={name:"color-bit",vertex:{header:"\n            @in aColor: vec4<f32>;\n        ",main:"\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        "}},o={name:"color-bit",vertex:{header:"\n            in vec4 aColor;\n        ",main:"\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        "}}},1570:function(e,n,t){t.d(n,{P:function(){return l},_:function(){return s}});const r={};function o(e){const n=[];if(1===e)n.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"),n.push("@group(1) @binding(1) var textureSampler1: sampler;");else{let t=0;for(let r=0;r<e;r++)n.push(`@group(1) @binding(${t++}) var textureSource${r+1}: texture_2d<f32>;`),n.push(`@group(1) @binding(${t++}) var textureSampler${r+1}: sampler;`)}return n.join("\n")}function i(e){const n=[];if(1===e)n.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");else{n.push("switch vTextureId {");for(let t=0;t<e;t++)t===e-1?n.push("  default:{"):n.push(`  case ${t}:{`),n.push(`      outColor = textureSampleGrad(textureSource${t+1}, textureSampler${t+1}, vUV, uvDx, uvDy);`),n.push("      break;}");n.push("}")}return n.join("\n")}function s(e){return r[e]||(r[e]={name:"texture-batch-bit",vertex:{header:"\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            ",main:"\n                vTextureId = aTextureIdAndRound.y;\n            ",end:"\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            "},fragment:{header:`\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${o(16)}\n            `,main:`\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${i(16)}\n            `}}),r[e]}const u={};function a(e){const n=[];for(let t=0;t<e;t++)t>0&&n.push("else"),t<e-1&&n.push(`if(vTextureId < ${t}.5)`),n.push("{"),n.push(`\toutColor = texture(uTextures[${t}], vUV);`),n.push("}");return n.join("\n")}function l(e){return u[e]||(u[e]={name:"texture-batch-bit",vertex:{header:"\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            ",main:"\n                vTextureId = aTextureIdAndRound.y;\n            ",end:"\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            "},fragment:{header:`\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${e}];\n              \n            `,main:`\n    \n                ${a(16)}\n            `}}),u[e]}},4405:function(e,n,t){t.d(n,{Ls:function(){return r},_Q:function(){return o},mA:function(){return i}});const r={name:"local-uniform-bit",vertex:{header:"\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ",main:"\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ",end:"\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        "}},o={...r,vertex:{...r.vertex,header:r.vertex.header.replace("group(1)","group(2)")}},i={name:"local-uniform-bit",vertex:{header:"\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ",main:"\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        ",end:"\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        "}}},7335:function(e,n,t){t.d(n,{b:function(){return r},m:function(){return o}});const r={name:"round-pixels-bit",vertex:{header:"\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;\n            }\n        "}},o={name:"round-pixels-bit",vertex:{header:"   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor((position * 0.5 + 0.5) * targetSize) / targetSize) * 2.0 - 1.0;\n            }\n        "}}},836:function(e,n,t){t.d(n,{M:function(){return m}});var r=t(8642),o=t(5423);let i,s;function u(){if(!s){s="mediump";const e=function(){if(!i||i?.isContextLost()){const e=o.e.get().createCanvas();i=e.getContext("webgl",{})}return i}();if(e&&e.getShaderPrecisionFormat){const n=e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_FLOAT);s=n.precision?"highp":"mediump"}}return s}const a={},l={},c={stripVersion:function(e,n){return n?e.replace("#version 300 es",""):e},ensurePrecision:function(e,n,t){const r=t?n.maxSupportedFragmentPrecision:n.maxSupportedVertexPrecision;if("precision"!==e.substring(0,9)){let o=t?n.requestedFragmentPrecision:n.requestedVertexPrecision;return"highp"===o&&"highp"!==r&&(o="mediump"),`precision ${o} float;\n${e}`}return"highp"!==r&&"precision highp"===e.substring(0,15)?e.replace("precision highp","precision mediump"):e},addProgramDefines:function(e,n,t){return n?e:t?`\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${e=e.replace("out vec4 finalColor;","")}\n        `:`\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${e}\n        `},setProgramName:function(e,{name:n="pixi-program"},t=!0){n=n.replace(/\s+/g,"-");const r=t?a:l;return r[n+=t?"-fragment":"-vertex"]?(r[n]++,n+=`-${r[n]}`):r[n]=1,-1!==e.indexOf("#define SHADER_NAME")?e:`#define SHADER_NAME ${n}\n${e}`},insertVersion:function(e,n){return n?`#version 300 es\n${e}`:e}},d=Object.create(null),f=class e{constructor(n){const t=-1!==(n={...e.defaultOptions,...n}).fragment.indexOf("#version 300 es"),o={stripVersion:t,ensurePrecision:{requestedFragmentPrecision:n.preferredFragmentPrecision,requestedVertexPrecision:n.preferredVertexPrecision,maxSupportedVertexPrecision:"highp",maxSupportedFragmentPrecision:u()},setProgramName:{name:n.name},addProgramDefines:t,insertVersion:t};let i=n.fragment,s=n.vertex;Object.keys(c).forEach((e=>{const n=o[e];i=c[e](i,n,!0),s=c[e](s,n,!1)})),this.fragment=i,this.vertex=s,this._key=(0,r.X)(`${this.vertex}:${this.fragment}`,"gl-program")}destroy(){this.fragment=null,this.vertex=null,this._attributeData=null,this._uniformData=null,this._uniformBlockData=null,this.transformFeedbackVaryings=null}static from(n){const t=`${n.vertex}:${n.fragment}`;return d[t]||(d[t]=new e(n)),d[t]}};f.defaultOptions={preferredVertexPrecision:"highp",preferredFragmentPrecision:"mediump"};let m=f},1790:function(e,n,t){t.d(n,{B:function(){return l}});var r=t(8642),o=t(4988);const i={f32:"float32","vec2<f32>":"float32x2","vec3<f32>":"float32x3","vec4<f32>":"float32x4",vec2f:"float32x2",vec3f:"float32x3",vec4f:"float32x4",i32:"sint32","vec2<i32>":"sint32x2","vec3<i32>":"sint32x3","vec4<i32>":"sint32x4",u32:"uint32","vec2<u32>":"uint32x2","vec3<u32>":"uint32x3","vec4<u32>":"uint32x4",bool:"uint32","vec2<bool>":"uint32x2","vec3<bool>":"uint32x3","vec4<bool>":"uint32x4"};function s(e){const n=/@group\((\d+)\)/,t=/@binding\((\d+)\)/,r=/var(<[^>]+>)? (\w+)/,o=/:\s*(\w+)/,i=/(\w+)\s*:\s*([\w\<\>]+)/g,s=/struct\s+(\w+)/,u=e.match(/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g)?.map((e=>({group:parseInt(e.match(n)[1],10),binding:parseInt(e.match(t)[1],10),name:e.match(r)[2],isUniform:"<uniform>"===e.match(r)[1],type:e.match(o)[1]})));if(!u)return{groups:[],structs:[]};const a=e.match(/struct\s+(\w+)\s*{([^}]+)}/g)?.map((e=>{const n=e.match(s)[1],t=e.match(i).reduce(((e,n)=>{const[t,r]=n.split(":");return e[t.trim()]=r.trim(),e}),{});return t?{name:n,members:t}:null})).filter((({name:e})=>u.some((n=>n.type===e))))??[];return{groups:u,structs:a}}var u=(e=>(e[e.VERTEX=1]="VERTEX",e[e.FRAGMENT=2]="FRAGMENT",e[e.COMPUTE=4]="COMPUTE",e))(u||{});const a=Object.create(null);class l{constructor(e){this._layoutKey=0;const{fragment:n,vertex:t,layout:r,gpuLayout:o,name:i}=e;if(this.name=i,this.fragment=n,this.vertex=t,n.source===t.source){const e=s(n.source);this.structsAndGroups=e}else{const e=s(t.source),r=s(n.source);this.structsAndGroups=function(e,n){const t=new Set,r=new Set;return{structs:[...e.structs,...n.structs].filter((e=>!t.has(e.name)&&(t.add(e.name),!0))),groups:[...e.groups,...n.groups].filter((e=>{const n=`${e.name}-${e.binding}`;return!r.has(n)&&(r.add(n),!0)}))}}(e,r)}this.layout=r??function({groups:e}){const n=[];for(let t=0;t<e.length;t++){const r=e[t];n[r.group]||(n[r.group]={}),n[r.group][r.name]=r.binding}return n}(this.structsAndGroups),this.gpuLayout=o??function({groups:e}){const n=[];for(let t=0;t<e.length;t++){const r=e[t];n[r.group]||(n[r.group]=[]),r.isUniform?n[r.group].push({binding:r.binding,visibility:u.VERTEX|u.FRAGMENT,buffer:{type:"uniform"}}):"sampler"===r.type?n[r.group].push({binding:r.binding,visibility:u.FRAGMENT,sampler:{type:"filtering"}}):"texture_2d"===r.type&&n[r.group].push({binding:r.binding,visibility:u.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}})}return n}(this.structsAndGroups),this.autoAssignGlobalUniforms=!(void 0===this.layout[0]?.globalUniforms),this.autoAssignLocalUniforms=!(void 0===this.layout[1]?.localUniforms),this._generateProgramKey()}_generateProgramKey(){const{vertex:e,fragment:n}=this,t=e.source+n.source+e.entryPoint+n.entryPoint;this._layoutKey=(0,r.X)(t,"program")}get attributeData(){return this._attributeData??(this._attributeData=function({source:e,entryPoint:n}){const t={},r=e.indexOf(`fn ${n}`);if(-1!==r){const n=e.indexOf("->",r);if(-1!==n){const s=e.substring(r,n),u=/@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;let a;for(;null!==(a=u.exec(s));){const e=i[a[3]]??"float32";t[a[2]]={location:parseInt(a[1],10),format:e,stride:(0,o.m)(e).stride,offset:0,instance:!1,start:0}}}}return t}(this.vertex)),this._attributeData}destroy(){this.gpuLayout=null,this.layout=null,this.structsAndGroups=null,this.fragment=null,this.vertex=null}static from(e){const n=`${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`;return a[n]||(a[n]=new l(e)),a[n]}}},4988:function(e,n,t){t.d(n,{m:function(){return o}});const r={uint8x2:{size:2,stride:2,normalised:!1},uint8x4:{size:4,stride:4,normalised:!1},sint8x2:{size:2,stride:2,normalised:!1},sint8x4:{size:4,stride:4,normalised:!1},unorm8x2:{size:2,stride:2,normalised:!0},unorm8x4:{size:4,stride:4,normalised:!0},snorm8x2:{size:2,stride:2,normalised:!0},snorm8x4:{size:4,stride:4,normalised:!0},uint16x2:{size:2,stride:4,normalised:!1},uint16x4:{size:4,stride:8,normalised:!1},sint16x2:{size:2,stride:4,normalised:!1},sint16x4:{size:4,stride:8,normalised:!1},unorm16x2:{size:2,stride:4,normalised:!0},unorm16x4:{size:4,stride:8,normalised:!0},snorm16x2:{size:2,stride:4,normalised:!0},snorm16x4:{size:4,stride:8,normalised:!0},float16x2:{size:2,stride:4,normalised:!1},float16x4:{size:4,stride:8,normalised:!1},float32:{size:1,stride:4,normalised:!1},float32x2:{size:2,stride:8,normalised:!1},float32x3:{size:3,stride:12,normalised:!1},float32x4:{size:4,stride:16,normalised:!1},uint32:{size:1,stride:4,normalised:!1},uint32x2:{size:2,stride:8,normalised:!1},uint32x3:{size:3,stride:12,normalised:!1},uint32x4:{size:4,stride:16,normalised:!1},sint32:{size:1,stride:4,normalised:!1},sint32x2:{size:2,stride:8,normalised:!1},sint32x3:{size:3,stride:12,normalised:!1},sint32x4:{size:4,stride:16,normalised:!1}};function o(e){return r[e]??r.float32}},1657:function(e,n,t){t.d(n,{M:function(){return l}});var r=t(4872),o=t(836),i=t(3655),s=t(1790),u=t(5153),a=t(8200);class l extends r.A{constructor(e){super(),this._uniformBindMap=Object.create(null),this._ownedBindGroups=[];let{gpuProgram:n,glProgram:t,groups:r,resources:o,compatibleRenderers:s,groupMap:l}=e;this.gpuProgram=n,this.glProgram=t,void 0===s&&(s=0,n&&(s|=u.W.WEBGPU),t&&(s|=u.W.WEBGL)),this.compatibleRenderers=s;const c={};if(o||r||(o={}),o&&r)throw new Error("[Shader] Cannot have both resources and groups");if(!n&&r&&!l)throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");if(!n&&r&&l)for(const e in l)for(const n in l[e]){const t=l[e][n];c[t]={group:e,binding:n,name:t}}else if(n&&r&&!l){const e=n.structsAndGroups.groups;l={},e.forEach((e=>{l[e.group]=l[e.group]||{},l[e.group][e.binding]=e.name,c[e.name]=e}))}else if(o){if(n){const e=n.structsAndGroups.groups;l={},e.forEach((e=>{l[e.group]=l[e.group]||{},l[e.group][e.binding]=e.name,c[e.name]=e}))}else{l={},r={99:new i.T},this._ownedBindGroups.push(r[99]);let e=0;for(const n in o)c[n]={group:99,binding:e,name:n},l[99]=l[99]||{},l[99][e]=n,e++}r={};for(const e in o){const n=e;let t=o[e];t.source||t._resourceType||(t=new a.k(t));const s=c[n];s&&(r[s.group]||(r[s.group]=new i.T,this._ownedBindGroups.push(r[s.group])),r[s.group].setResource(t,s.binding))}}this.groups=r,this._uniformBindMap=l,this.resources=this._buildResourceAccessor(r,c)}addResource(e,n,t){var r,o;(r=this._uniformBindMap)[n]||(r[n]={}),(o=this._uniformBindMap[n])[t]||(o[t]=e),this.groups[n]||(this.groups[n]=new i.T,this._ownedBindGroups.push(this.groups[n]))}_buildResourceAccessor(e,n){const t={};for(const r in n){const o=n[r];Object.defineProperty(t,o.name,{get(){return e[o.group].getResource(o.binding)},set(n){e[o.group].setResource(n,o.binding)}})}return t}destroy(e=!1){this.emit("destroy",this),e&&(this.gpuProgram?.destroy(),this.glProgram?.destroy()),this.gpuProgram=null,this.glProgram=null,this.removeAllListeners(),this._uniformBindMap=null,this._ownedBindGroups.forEach((e=>{e.destroy()})),this._ownedBindGroups=null,this.resources=null,this.groups=null}static from(e){const{gpu:n,gl:t,...r}=e;let i,u;return n&&(i=s.B.from(n)),t&&(u=o.M.from(t)),new l({gpuProgram:i,glProgram:u,...r})}}},8200:function(e,n,t){t.d(n,{k:function(){return u}});var r=t(9375),o=t(8642);function i(e,n){switch(e){case"f32":return 0;case"vec2<f32>":return new Float32Array(2*n);case"vec3<f32>":return new Float32Array(3*n);case"vec4<f32>":return new Float32Array(4*n);case"mat2x2<f32>":return new Float32Array([1,0,0,1]);case"mat3x3<f32>":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4x4<f32>":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const s=class e{constructor(n,t){this._touched=0,this.uid=(0,r.L)("uniform"),this._resourceType="uniformGroup",this._resourceId=(0,r.L)("resource"),this.isUniformGroup=!0,this._dirtyId=0,t={...e.defaultOptions,...t},this.uniformStructures=n;const s={};for(const e in n){const t=n[e];t.name=e,t.size=t.size??1,t.value??(t.value=i(t.type,t.size)),s[e]=t.value}this.uniforms=s,this._dirtyId=1,this.ubo=t.ubo,this.isStatic=t.isStatic,this._signature=(0,o.X)(Object.keys(s).map((e=>`${e}-${n[e].type}`)).join("-"),"uniform-group")}update(){this._dirtyId++}};s.defaultOptions={ubo:!1,isStatic:!1};let u=s},7433:function(e,n,t){t.d(n,{U:function(){return i}});const r={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8},o=class e{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(1&this.data)}set blend(e){!!(1&this.data)!==e&&(this.data^=1)}get offsets(){return!!(2&this.data)}set offsets(e){!!(2&this.data)!==e&&(this.data^=2)}set cullMode(e){"none"!==e?(this.culling=!0,this.clockwiseFrontFace="front"===e):this.culling=!1}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(4&this.data)}set culling(e){!!(4&this.data)!==e&&(this.data^=4)}get depthTest(){return!!(8&this.data)}set depthTest(e){!!(8&this.data)!==e&&(this.data^=8)}get depthMask(){return!!(32&this.data)}set depthMask(e){!!(32&this.data)!==e&&(this.data^=32)}get clockwiseFrontFace(){return!!(16&this.data)}set clockwiseFrontFace(e){!!(16&this.data)!==e&&(this.data^=16)}get blendMode(){return this._blendMode}set blendMode(e){this.blend="none"!==e,this._blendMode=e,this._blendModeId=r[e]||0}get polygonOffset(){return this._polygonOffset}set polygonOffset(e){this.offsets=!!e,this._polygonOffset=e}toString(){return`[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`}static for2d(){const n=new e;return n.depthTest=!1,n.blend=!0,n}};o.default2d=o.for2d();let i=o},8851:function(e,n,t){t.d(n,{W:function(){return u}});var r=t(9437),o=t(1818),i=t(8830);let s=0;const u=new class{constructor(e){this._poolKeyHash=Object.create(null),this._texturePool={},this.textureOptions=e||{},this.enableFullScreen=!1}createTexture(e,n,t){const r=new o.v({...this.textureOptions,width:e,height:n,resolution:1,antialias:t,autoGarbageCollect:!0});return new i.g({source:r,label:"texturePool_"+s++})}getOptimalTexture(e,n,t=1,o){let i=Math.ceil(e*t-1e-6),s=Math.ceil(n*t-1e-6);i=(0,r.U5)(i),s=(0,r.U5)(s);const u=(i<<17)+(s<<1)+(o?1:0);this._texturePool[u]||(this._texturePool[u]=[]);let a=this._texturePool[u].pop();return a||(a=this.createTexture(i,s,o)),a.source._resolution=t,a.source.width=i/t,a.source.height=s/t,a.source.pixelWidth=i,a.source.pixelHeight=s,a.frame.x=0,a.frame.y=0,a.frame.width=e,a.frame.height=n,a.updateUvs(),this._poolKeyHash[a.uid]=u,a}getSameSizeTexture(e,n=!1){const t=e.source;return this.getOptimalTexture(e.width,e.height,t._resolution,n)}returnTexture(e){const n=this._poolKeyHash[e.uid];this._texturePool[n].push(e)}clear(e){if(e=!1!==e)for(const e in this._texturePool){const n=this._texturePool[e];if(n)for(let e=0;e<n.length;e++)n[e].destroy(!0)}this._texturePool={}}}},8642:function(e,n,t){t.d(n,{X:function(){return i}});const r=Object.create(null),o=Object.create(null);function i(e,n){let t=o[e];return void 0===t&&(void 0===r[n]&&(r[n]=1),o[e]=t=r[n]++),t}},5153:function(e,n,t){t.d(n,{W:function(){return r}});var r=(e=>(e[e.WEBGL=1]="WEBGL",e[e.WEBGPU=2]="WEBGPU",e[e.BOTH=3]="BOTH",e))(r||{})},9482:function(e,n,t){function r(e,n,t){const r=(e>>24&255)/255;n[t++]=(255&e)/255*r,n[t++]=(e>>8&255)/255*r,n[t++]=(e>>16&255)/255*r,n[t++]=r}t.d(n,{V:function(){return r}})},3412:function(e,n,t){t.d(n,{K:function(){return r}});class r{constructor(){this.vertexSize=4,this.indexSize=6,this.location=0,this.batcher=null,this.batch=null,this.roundPixels=0}get blendMode(){return this.renderable.groupBlendMode}packAttributes(e,n,t,r){const o=this.renderable,i=this.texture,s=o.groupTransform,u=s.a,a=s.b,l=s.c,c=s.d,d=s.tx,f=s.ty,m=this.bounds,h=m.maxX,p=m.minX,g=m.maxY,x=m.minY,v=i.uvs,b=o.groupColorAlpha,y=r<<16|65535&this.roundPixels;e[t+0]=u*p+l*x+d,e[t+1]=c*x+a*p+f,e[t+2]=v.x0,e[t+3]=v.y0,n[t+4]=b,n[t+5]=y,e[t+6]=u*h+l*x+d,e[t+7]=c*x+a*h+f,e[t+8]=v.x1,e[t+9]=v.y1,n[t+10]=b,n[t+11]=y,e[t+12]=u*h+l*g+d,e[t+13]=c*g+a*h+f,e[t+14]=v.x2,e[t+15]=v.y2,n[t+16]=b,n[t+17]=y,e[t+18]=u*p+l*g+d,e[t+19]=c*g+a*p+f,e[t+20]=v.x3,e[t+21]=v.y3,n[t+22]=b,n[t+23]=y}packIndex(e,n,t){e[n]=t+0,e[n+1]=t+1,e[n+2]=t+2,e[n+3]=t+0,e[n+4]=t+2,e[n+5]=t+3}reset(){this.renderable=null,this.texture=null,this.batcher=null,this.batch=null,this.bounds=null}}}}]);