"use strict";(self.webpackChunktutorial_babel_pixijs=self.webpackChunktutorial_babel_pixijs||[]).push([[12],{9677:function(e,t,n){n.d(t,{I:function(){return $},v:function(){return T}});var r=n(5007),o=n(1790),i=n(7694);function s(e,t,n){if(e)for(const r in e){const o=t[r.toLocaleLowerCase()];if(o){let t=e[r];"header"===r&&(t=t.replace(/@in\s+[^;]+;\s*/g,"").replace(/@out\s+[^;]+;\s*/g,"")),n&&o.push(`//----${n}----//`),o.push(t)}else(0,i.R)(`${r} placement hook does not exist in shader`)}}const u=/\{\{(.*?)\}\}/g;function a(e){const t={};return(e.match(u)?.map((e=>e.replace(/[{()}]/g,"")))??[]).forEach((e=>{t[e]=[]})),t}function l(e,t){let n;const r=/@in\s+([^;]+);/g;for(;null!==(n=r.exec(e));)t.push(n[1])}function c(e,t,n=!1){const r=[];l(t,r),e.forEach((e=>{e.header&&l(e.header,r)}));const o=r;n&&o.sort();const i=o.map(((e,t)=>`       @location(${t}) ${e},`)).join("\n");let s=t.replace(/@in\s+[^;]+;\s*/g,"");return s=s.replace("{{in}}",`\n${i}\n`),s}function d(e,t){let n;const r=/@out\s+([^;]+);/g;for(;null!==(n=r.exec(e));)t.push(n[1])}function f(e,t){let n=e;for(const e in t){const r=t[e];n=r.join("\n").length?n.replace(`{{${e}}}`,`//-----${e} START-----//\n${r.join("\n")}\n//----${e} FINISH----//`):n.replace(`{{${e}}}`,"")}return n}const m=Object.create(null),h=new Map;let p=0;function g({template:e,bits:t}){const n=x(e,t);return m[n]||(m[n]=v(e.vertex,e.fragment,t)),m[n]}function x(e,t){return t.map((e=>(h.has(e)||h.set(e,p++),h.get(e)))).sort(((e,t)=>e-t)).join("-")+e.vertex+e.fragment}function v(e,t,n){const r=a(e),o=a(t);return n.forEach((e=>{s(e.vertex,r,e.name),s(e.fragment,o,e.name)})),{vertex:f(e,r),fragment:f(t,o)}}const b="\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n",y="\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n",P="\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n",_="\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n",w={name:"global-uniforms-bit",vertex:{header:"\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        "}},M={name:"global-uniforms-bit",vertex:{header:"\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        "}};function T({bits:e,name:t}){const n=function({template:e,bits:t}){const n=x(e,t);if(m[n])return m[n];const{vertex:r,fragment:o}=function(e,t){const n=t.map((e=>e.vertex)).filter((e=>!!e)),r=t.map((e=>e.fragment)).filter((e=>!!e));let o=c(n,e.vertex,!0);return o=function(e,t){const n=[];d(t,n),e.forEach((e=>{e.header&&d(e.header,n)}));let r=0;const o=n.sort().map((e=>e.indexOf("builtin")>-1?e:`@location(${r++}) ${e}`)).join(",\n"),i=n.sort().map((e=>{return`       var ${t=e,t.replace(/@.*?\s+/g,"")};`;var t})).join("\n"),s=`return VSOutput(\n                ${n.sort().map((e=>` ${function(e){const t=/\b(\w+)\s*:/g.exec(e);return t?t[1]:""}(e)}`)).join(",\n")});`;let u=t.replace(/@out\s+[^;]+;\s*/g,"");return u=u.replace("{{struct}}",`\n${o}\n`),u=u.replace("{{start}}",`\n${i}\n`),u=u.replace("{{return}}",`\n${s}\n`),u}(n,o),{vertex:o,fragment:c(r,e.fragment,!0)}}(e,t);return m[n]=v(r,o,t),m[n]}({template:{fragment:y,vertex:b},bits:[w,...e]});return o.B.from({name:t,vertex:{source:n.vertex,entryPoint:"main"},fragment:{source:n.fragment,entryPoint:"main"}})}function $({bits:e,name:t}){return new r.M({name:t,...g({template:{vertex:P,fragment:_},bits:[M,...e]})})}},2305:function(e,t,n){n.d(t,{F:function(){return r},a:function(){return o}});const r={name:"color-bit",vertex:{header:"\n            @in aColor: vec4<f32>;\n        ",main:"\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        "}},o={name:"color-bit",vertex:{header:"\n            in vec4 aColor;\n        ",main:"\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        "}}},1570:function(e,t,n){n.d(t,{P:function(){return l},_:function(){return s}});const r={};function o(e){const t=[];if(1===e)t.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"),t.push("@group(1) @binding(1) var textureSampler1: sampler;");else{let n=0;for(let r=0;r<e;r++)t.push(`@group(1) @binding(${n++}) var textureSource${r+1}: texture_2d<f32>;`),t.push(`@group(1) @binding(${n++}) var textureSampler${r+1}: sampler;`)}return t.join("\n")}function i(e){const t=[];if(1===e)t.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");else{t.push("switch vTextureId {");for(let n=0;n<e;n++)n===e-1?t.push("  default:{"):t.push(`  case ${n}:{`),t.push(`      outColor = textureSampleGrad(textureSource${n+1}, textureSampler${n+1}, vUV, uvDx, uvDy);`),t.push("      break;}");t.push("}")}return t.join("\n")}function s(e){return r[e]||(r[e]={name:"texture-batch-bit",vertex:{header:"\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            ",main:"\n                vTextureId = aTextureIdAndRound.y;\n            ",end:"\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            "},fragment:{header:`\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${o(e)}\n            `,main:`\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${i(e)}\n            `}}),r[e]}const u={};function a(e){const t=[];for(let n=0;n<e;n++)n>0&&t.push("else"),n<e-1&&t.push(`if(vTextureId < ${n}.5)`),t.push("{"),t.push(`\toutColor = texture(uTextures[${n}], vUV);`),t.push("}");return t.join("\n")}function l(e){return u[e]||(u[e]={name:"texture-batch-bit",vertex:{header:"\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            ",main:"\n                vTextureId = aTextureIdAndRound.y;\n            ",end:"\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            "},fragment:{header:`\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${e}];\n\n            `,main:`\n\n                ${a(e)}\n            `}}),u[e]}},4405:function(e,t,n){n.d(t,{Ls:function(){return r},_Q:function(){return o},mA:function(){return i}});const r={name:"local-uniform-bit",vertex:{header:"\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ",main:"\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ",end:"\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        "}},o={...r,vertex:{...r.vertex,header:r.vertex.header.replace("group(1)","group(2)")}},i={name:"local-uniform-bit",vertex:{header:"\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ",main:"\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        ",end:"\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        "}}},7335:function(e,t,n){n.d(t,{b:function(){return r},m:function(){return o}});const r={name:"round-pixels-bit",vertex:{header:"\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        "}},o={name:"round-pixels-bit",vertex:{header:"   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        "}}},5007:function(e,t,n){n.d(t,{M:function(){return f}});var r=n(8642),o=n(8574);let i;function s(){if(!i){i="mediump";const e=(0,o.W)();if(e&&e.getShaderPrecisionFormat){const t=e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_FLOAT);i=t.precision?"highp":"mediump"}}return i}const u={},a={},l={stripVersion:function(e,t){return t?e.replace("#version 300 es",""):e},ensurePrecision:function(e,t,n){const r=n?t.maxSupportedFragmentPrecision:t.maxSupportedVertexPrecision;if("precision"!==e.substring(0,9)){let o=n?t.requestedFragmentPrecision:t.requestedVertexPrecision;return"highp"===o&&"highp"!==r&&(o="mediump"),`precision ${o} float;\n${e}`}return"highp"!==r&&"precision highp"===e.substring(0,15)?e.replace("precision highp","precision mediump"):e},addProgramDefines:function(e,t,n){return t?e:n?`\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${e=e.replace("out vec4 finalColor;","")}\n        `:`\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${e}\n        `},setProgramName:function(e,{name:t="pixi-program"},n=!0){t=t.replace(/\s+/g,"-");const r=n?u:a;return r[t+=n?"-fragment":"-vertex"]?(r[t]++,t+=`-${r[t]}`):r[t]=1,-1!==e.indexOf("#define SHADER_NAME")?e:`#define SHADER_NAME ${t}\n${e}`},insertVersion:function(e,t){return t?`#version 300 es\n${e}`:e}},c=Object.create(null),d=class e{constructor(t){const n=-1!==(t={...e.defaultOptions,...t}).fragment.indexOf("#version 300 es"),o={stripVersion:n,ensurePrecision:{requestedFragmentPrecision:t.preferredFragmentPrecision,requestedVertexPrecision:t.preferredVertexPrecision,maxSupportedVertexPrecision:"highp",maxSupportedFragmentPrecision:s()},setProgramName:{name:t.name},addProgramDefines:n,insertVersion:n};let i=t.fragment,u=t.vertex;Object.keys(l).forEach((e=>{const t=o[e];i=l[e](i,t,!0),u=l[e](u,t,!1)})),this.fragment=i,this.vertex=u,this._key=(0,r.X)(`${this.vertex}:${this.fragment}`,"gl-program")}destroy(){this.fragment=null,this.vertex=null,this._attributeData=null,this._uniformData=null,this._uniformBlockData=null,this.transformFeedbackVaryings=null}static from(t){const n=`${t.vertex}:${t.fragment}`;return c[n]||(c[n]=new e(t)),c[n]}};d.defaultOptions={preferredVertexPrecision:"highp",preferredFragmentPrecision:"mediump"};let f=d},1790:function(e,t,n){n.d(t,{B:function(){return l}});var r=n(8642),o=n(4988);const i={f32:"float32","vec2<f32>":"float32x2","vec3<f32>":"float32x3","vec4<f32>":"float32x4",vec2f:"float32x2",vec3f:"float32x3",vec4f:"float32x4",i32:"sint32","vec2<i32>":"sint32x2","vec3<i32>":"sint32x3","vec4<i32>":"sint32x4",u32:"uint32","vec2<u32>":"uint32x2","vec3<u32>":"uint32x3","vec4<u32>":"uint32x4",bool:"uint32","vec2<bool>":"uint32x2","vec3<bool>":"uint32x3","vec4<bool>":"uint32x4"};function s(e){const t=/@group\((\d+)\)/,n=/@binding\((\d+)\)/,r=/var(<[^>]+>)? (\w+)/,o=/:\s*(\w+)/,i=/(\w+)\s*:\s*([\w\<\>]+)/g,s=/struct\s+(\w+)/,u=e.match(/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g)?.map((e=>({group:parseInt(e.match(t)[1],10),binding:parseInt(e.match(n)[1],10),name:e.match(r)[2],isUniform:"<uniform>"===e.match(r)[1],type:e.match(o)[1]})));if(!u)return{groups:[],structs:[]};const a=e.match(/struct\s+(\w+)\s*{([^}]+)}/g)?.map((e=>{const t=e.match(s)[1],n=e.match(i).reduce(((e,t)=>{const[n,r]=t.split(":");return e[n.trim()]=r.trim(),e}),{});return n?{name:t,members:n}:null})).filter((({name:e})=>u.some((t=>t.type===e))))??[];return{groups:u,structs:a}}var u=(e=>(e[e.VERTEX=1]="VERTEX",e[e.FRAGMENT=2]="FRAGMENT",e[e.COMPUTE=4]="COMPUTE",e))(u||{});const a=Object.create(null);class l{constructor(e){this._layoutKey=0,this._attributeLocationsKey=0;const{fragment:t,vertex:n,layout:r,gpuLayout:o,name:i}=e;if(this.name=i,this.fragment=t,this.vertex=n,t.source===n.source){const e=s(t.source);this.structsAndGroups=e}else{const e=s(n.source),r=s(t.source);this.structsAndGroups=function(e,t){const n=new Set,r=new Set;return{structs:[...e.structs,...t.structs].filter((e=>!n.has(e.name)&&(n.add(e.name),!0))),groups:[...e.groups,...t.groups].filter((e=>{const t=`${e.name}-${e.binding}`;return!r.has(t)&&(r.add(t),!0)}))}}(e,r)}this.layout=r??function({groups:e}){const t=[];for(let n=0;n<e.length;n++){const r=e[n];t[r.group]||(t[r.group]={}),t[r.group][r.name]=r.binding}return t}(this.structsAndGroups),this.gpuLayout=o??function({groups:e}){const t=[];for(let n=0;n<e.length;n++){const r=e[n];t[r.group]||(t[r.group]=[]),r.isUniform?t[r.group].push({binding:r.binding,visibility:u.VERTEX|u.FRAGMENT,buffer:{type:"uniform"}}):"sampler"===r.type?t[r.group].push({binding:r.binding,visibility:u.FRAGMENT,sampler:{type:"filtering"}}):"texture_2d"===r.type&&t[r.group].push({binding:r.binding,visibility:u.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}})}return t}(this.structsAndGroups),this.autoAssignGlobalUniforms=!(void 0===this.layout[0]?.globalUniforms),this.autoAssignLocalUniforms=!(void 0===this.layout[1]?.localUniforms),this._generateProgramKey()}_generateProgramKey(){const{vertex:e,fragment:t}=this,n=e.source+t.source+e.entryPoint+t.entryPoint;this._layoutKey=(0,r.X)(n,"program")}get attributeData(){return this._attributeData??(this._attributeData=function({source:e,entryPoint:t}){const n={},r=e.indexOf(`fn ${t}`);if(-1!==r){const t=e.indexOf("->",r);if(-1!==t){const s=e.substring(r,t),u=/@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;let a;for(;null!==(a=u.exec(s));){const e=i[a[3]]??"float32";n[a[2]]={location:parseInt(a[1],10),format:e,stride:(0,o.m)(e).stride,offset:0,instance:!1,start:0}}}}return n}(this.vertex)),this._attributeData}destroy(){this.gpuLayout=null,this.layout=null,this.structsAndGroups=null,this.fragment=null,this.vertex=null}static from(e){const t=`${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`;return a[t]||(a[t]=new l(e)),a[t]}}},4988:function(e,t,n){n.d(t,{m:function(){return o}});const r={uint8x2:{size:2,stride:2,normalised:!1},uint8x4:{size:4,stride:4,normalised:!1},sint8x2:{size:2,stride:2,normalised:!1},sint8x4:{size:4,stride:4,normalised:!1},unorm8x2:{size:2,stride:2,normalised:!0},unorm8x4:{size:4,stride:4,normalised:!0},snorm8x2:{size:2,stride:2,normalised:!0},snorm8x4:{size:4,stride:4,normalised:!0},uint16x2:{size:2,stride:4,normalised:!1},uint16x4:{size:4,stride:8,normalised:!1},sint16x2:{size:2,stride:4,normalised:!1},sint16x4:{size:4,stride:8,normalised:!1},unorm16x2:{size:2,stride:4,normalised:!0},unorm16x4:{size:4,stride:8,normalised:!0},snorm16x2:{size:2,stride:4,normalised:!0},snorm16x4:{size:4,stride:8,normalised:!0},float16x2:{size:2,stride:4,normalised:!1},float16x4:{size:4,stride:8,normalised:!1},float32:{size:1,stride:4,normalised:!1},float32x2:{size:2,stride:8,normalised:!1},float32x3:{size:3,stride:12,normalised:!1},float32x4:{size:4,stride:16,normalised:!1},uint32:{size:1,stride:4,normalised:!1},uint32x2:{size:2,stride:8,normalised:!1},uint32x3:{size:3,stride:12,normalised:!1},uint32x4:{size:4,stride:16,normalised:!1},sint32:{size:1,stride:4,normalised:!1},sint32x2:{size:2,stride:8,normalised:!1},sint32x3:{size:3,stride:12,normalised:!1},sint32x4:{size:4,stride:16,normalised:!1}};function o(e){return r[e]??r.float32}},1657:function(e,t,n){n.d(t,{M:function(){return l}});var r=n(4872),o=n(5007),i=n(3655),s=n(1790),u=n(5153),a=n(4449);class l extends r.A{constructor(e){super(),this._uniformBindMap=Object.create(null),this._ownedBindGroups=[];let{gpuProgram:t,glProgram:n,groups:r,resources:o,compatibleRenderers:s,groupMap:l}=e;this.gpuProgram=t,this.glProgram=n,void 0===s&&(s=0,t&&(s|=u.W.WEBGPU),n&&(s|=u.W.WEBGL)),this.compatibleRenderers=s;const c={};if(o||r||(o={}),o&&r)throw new Error("[Shader] Cannot have both resources and groups");if(!t&&r&&!l)throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");if(!t&&r&&l)for(const e in l)for(const t in l[e]){const n=l[e][t];c[n]={group:e,binding:t,name:n}}else if(t&&r&&!l){const e=t.structsAndGroups.groups;l={},e.forEach((e=>{l[e.group]=l[e.group]||{},l[e.group][e.binding]=e.name,c[e.name]=e}))}else if(o){r={},l={},t&&t.structsAndGroups.groups.forEach((e=>{l[e.group]=l[e.group]||{},l[e.group][e.binding]=e.name,c[e.name]=e}));let e=0;for(const t in o)c[t]||(r[99]||(r[99]=new i.T,this._ownedBindGroups.push(r[99])),c[t]={group:99,binding:e,name:t},l[99]=l[99]||{},l[99][e]=t,e++);for(const e in o){const t=e;let n=o[e];n.source||n._resourceType||(n=new a.k(n));const s=c[t];s&&(r[s.group]||(r[s.group]=new i.T,this._ownedBindGroups.push(r[s.group])),r[s.group].setResource(n,s.binding))}}this.groups=r,this._uniformBindMap=l,this.resources=this._buildResourceAccessor(r,c)}addResource(e,t,n){var r,o;(r=this._uniformBindMap)[t]||(r[t]={}),(o=this._uniformBindMap[t])[n]||(o[n]=e),this.groups[t]||(this.groups[t]=new i.T,this._ownedBindGroups.push(this.groups[t]))}_buildResourceAccessor(e,t){const n={};for(const r in t){const o=t[r];Object.defineProperty(n,o.name,{get(){return e[o.group].getResource(o.binding)},set(t){e[o.group].setResource(t,o.binding)}})}return n}destroy(e=!1){this.emit("destroy",this),e&&(this.gpuProgram?.destroy(),this.glProgram?.destroy()),this.gpuProgram=null,this.glProgram=null,this.removeAllListeners(),this._uniformBindMap=null,this._ownedBindGroups.forEach((e=>{e.destroy()})),this._ownedBindGroups=null,this.resources=null,this.groups=null}static from(e){const{gpu:t,gl:n,...r}=e;let i,u;return t&&(i=s.B.from(t)),n&&(u=o.M.from(n)),new l({gpuProgram:i,glProgram:u,...r})}}},4449:function(e,t,n){n.d(t,{k:function(){return l}});var r=n(9375),o=n(8642);const i=["f32","i32","vec2<f32>","vec3<f32>","vec4<f32>","mat2x2<f32>","mat3x3<f32>","mat4x4<f32>","mat3x2<f32>","mat4x2<f32>","mat2x3<f32>","mat4x3<f32>","mat2x4<f32>","mat3x4<f32>"],s=i.reduce(((e,t)=>(e[t]=!0,e)),{});function u(e,t){switch(e){case"f32":return 0;case"vec2<f32>":return new Float32Array(2*t);case"vec3<f32>":return new Float32Array(3*t);case"vec4<f32>":return new Float32Array(4*t);case"mat2x2<f32>":return new Float32Array([1,0,0,1]);case"mat3x3<f32>":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4x4<f32>":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const a=class e{constructor(t,n){this._touched=0,this.uid=(0,r.L)("uniform"),this._resourceType="uniformGroup",this._resourceId=(0,r.L)("resource"),this.isUniformGroup=!0,this._dirtyId=0,this.destroyed=!1,n={...e.defaultOptions,...n},this.uniformStructures=t;const a={};for(const e in t){const n=t[e];if(n.name=e,n.size=n.size??1,!s[n.type])throw new Error(`Uniform type ${n.type} is not supported. Supported uniform types are: ${i.join(", ")}`);n.value??(n.value=u(n.type,n.size)),a[e]=n.value}this.uniforms=a,this._dirtyId=1,this.ubo=n.ubo,this.isStatic=n.isStatic,this._signature=(0,o.X)(Object.keys(a).map((e=>`${e}-${t[e].type}`)).join("-"),"uniform-group")}update(){this._dirtyId++}};a.defaultOptions={ubo:!1,isStatic:!1};let l=a},7433:function(e,t,n){n.d(t,{U:function(){return i}});const r={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8,min:9,max:10},o=class e{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(1&this.data)}set blend(e){!!(1&this.data)!==e&&(this.data^=1)}get offsets(){return!!(2&this.data)}set offsets(e){!!(2&this.data)!==e&&(this.data^=2)}set cullMode(e){"none"!==e?(this.culling=!0,this.clockwiseFrontFace="front"===e):this.culling=!1}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(4&this.data)}set culling(e){!!(4&this.data)!==e&&(this.data^=4)}get depthTest(){return!!(8&this.data)}set depthTest(e){!!(8&this.data)!==e&&(this.data^=8)}get depthMask(){return!!(32&this.data)}set depthMask(e){!!(32&this.data)!==e&&(this.data^=32)}get clockwiseFrontFace(){return!!(16&this.data)}set clockwiseFrontFace(e){!!(16&this.data)!==e&&(this.data^=16)}get blendMode(){return this._blendMode}set blendMode(e){this.blend="none"!==e,this._blendMode=e,this._blendModeId=r[e]||0}get polygonOffset(){return this._polygonOffset}set polygonOffset(e){this.offsets=!!e,this._polygonOffset=e}toString(){return`[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`}static for2d(){const t=new e;return t.depthTest=!1,t.blend=!0,t}};o.default2d=o.for2d();let i=o},8851:function(e,t,n){n.d(t,{W:function(){return u}});var r=n(9437),o=n(1818),i=n(8830);let s=0;const u=new class{constructor(e){this._poolKeyHash=Object.create(null),this._texturePool={},this.textureOptions=e||{},this.enableFullScreen=!1}createTexture(e,t,n){const r=new o.v({...this.textureOptions,width:e,height:t,resolution:1,antialias:n,autoGarbageCollect:!0});return new i.g({source:r,label:"texturePool_"+s++})}getOptimalTexture(e,t,n=1,o){let i=Math.ceil(e*n-1e-6),s=Math.ceil(t*n-1e-6);i=(0,r.U5)(i),s=(0,r.U5)(s);const u=(i<<17)+(s<<1)+(o?1:0);this._texturePool[u]||(this._texturePool[u]=[]);let a=this._texturePool[u].pop();return a||(a=this.createTexture(i,s,o)),a.source._resolution=n,a.source.width=i/n,a.source.height=s/n,a.source.pixelWidth=i,a.source.pixelHeight=s,a.frame.x=0,a.frame.y=0,a.frame.width=e,a.frame.height=t,a.updateUvs(),this._poolKeyHash[a.uid]=u,a}getSameSizeTexture(e,t=!1){const n=e.source;return this.getOptimalTexture(e.width,e.height,n._resolution,t)}returnTexture(e){const t=this._poolKeyHash[e.uid];this._texturePool[t].push(e)}clear(e){if(e=!1!==e)for(const e in this._texturePool){const t=this._texturePool[e];if(t)for(let e=0;e<t.length;e++)t[e].destroy(!0)}this._texturePool={}}}},8642:function(e,t,n){n.d(t,{X:function(){return i}});const r=Object.create(null),o=Object.create(null);function i(e,t){let n=o[e];return void 0===n&&(void 0===r[t]&&(r[t]=1),o[e]=n=r[t]++),n}},5153:function(e,t,n){n.d(t,{W:function(){return r}});var r=(e=>(e[e.WEBGL=1]="WEBGL",e[e.WEBGPU=2]="WEBGPU",e[e.BOTH=3]="BOTH",e))(r||{})},9482:function(e,t,n){function r(e,t,n){const r=(e>>24&255)/255;t[n++]=(255&e)/255*r,t[n++]=(e>>8&255)/255*r,t[n++]=(e>>16&255)/255*r,t[n++]=r}n.d(t,{V:function(){return r}})},3412:function(e,t,n){n.d(t,{K:function(){return r}});class r{constructor(){this.vertexSize=4,this.indexSize=6,this.location=0,this.batcher=null,this.batch=null,this.roundPixels=0}get blendMode(){return this.renderable.groupBlendMode}packAttributes(e,t,n,r){const o=this.renderable,i=this.texture,s=o.groupTransform,u=s.a,a=s.b,l=s.c,c=s.d,d=s.tx,f=s.ty,m=this.bounds,h=m.maxX,p=m.minX,g=m.maxY,x=m.minY,v=i.uvs,b=o.groupColorAlpha,y=r<<16|65535&this.roundPixels;e[n+0]=u*p+l*x+d,e[n+1]=c*x+a*p+f,e[n+2]=v.x0,e[n+3]=v.y0,t[n+4]=b,t[n+5]=y,e[n+6]=u*h+l*x+d,e[n+7]=c*x+a*h+f,e[n+8]=v.x1,e[n+9]=v.y1,t[n+10]=b,t[n+11]=y,e[n+12]=u*h+l*g+d,e[n+13]=c*g+a*h+f,e[n+14]=v.x2,e[n+15]=v.y2,t[n+16]=b,t[n+17]=y,e[n+18]=u*p+l*g+d,e[n+19]=c*g+a*p+f,e[n+20]=v.x3,e[n+21]=v.y3,t[n+22]=b,t[n+23]=y}packIndex(e,t,n){e[t]=n+0,e[t+1]=n+1,e[t+2]=n+2,e[t+3]=n+0,e[t+4]=n+2,e[t+5]=n+3}reset(){this.renderable=null,this.texture=null,this.batcher=null,this.batch=null,this.bounds=null}}}}]);